- 스프링 : 자바 프레임워크
    - 프레임워크 : 여러 기능을 가진 클래스와 라이브러리가 합쳐진 형태/틀

- 스프링 셋팅
    - 인텔리제이 무료버전(커뮤니티) 스프링 프로젝트 지원 안함

    - 수업기준 : 그레이들 프로젝트
        - 그레이들[ 자동(라이브러리) 빌드 ]

    - 그레이들에 빌드할 의존성 추가 [ https://start.spring.io/ ]
        Project [ Gradle - Groovy ]
        Language [ Java ]
        Spring Boot [ 2.7.16 ]
        Package [ jar ]
        Java [ 8 ]
    - Dependencies
        Spring Web      : 스프링 웹 관련 라이브러리들을 지원
        Lombok          : 롬복 [ 생성자 , getter , setter , 빌더패턴 등등 ] 지원
        MySQL Driver    : mysql 연동 라이브러리
        <추후에 계속적으로 추가>

    - build.gradle 에 Dependencies 추가

- 프로젝트 폴더구성
    프로젝트명
        .gradle : bulid.gradle 빌드 파일 [ 임시파일 ]
        .idea   : 인텔리제이 셋팅 파일 [ 임시파일 ]
        .build  : JVM 빌드시 생성한 바이트파일 [ 임시파일 ]
        gradle : gradle 라이브러리 파일
        ****src : 개발자 코드 작성하는 공간
            main
                java		   : 백엔드

                resources	   : 프론트엔드[정적파일(html,css,js,img 등등)]
                    - static
                       css/js/img 등등
                    - templates
                    **** - application.properties : 현재 프로젝트 설정 소스 파일
                            - jpa

                ****bulid.gradle : 라이브러리 자동 빌드 해주는 작성 코드 파일


- 스프링부트 실행
	준비물 
	- main 함수 1개 필요 [ 스프링을 작동할 스레드 1개 필요 ]
	1. 클래스 1개 생성 [ 스프링 실행하는 클래스 이므로 모든 소스파일의 최상위 위치 ] 
	2. 클래스 상단
               @SpringBootApplication 주입
	3. main 선언
		      SpringApplication.run( 현재 클래스명.class );

- 어노테이션
    1. 스프링
             @SpringBootApplication             스프링부트 실행 관련 제공
             @ServletComponentScan              서블릿을 찾아서 컨테이너에 빈 등록
             @Autowired                         컨테이너에서 빈 찾아서 객체 주입
    2. MVC
             @Controller                        해당 클래스를 Controller 사용 주입 [ 컨테이너에 빈 등록 ]
             @RestController                    해당 클래스를 Controller 사용 주입 [ 컨테이너에 빈 등록 ] + @ResponseBody
             @ResponseBody                      해당 Mapping 함수들의 response 반환타입을 자동으로 설정
             @RequestMapping                    해당 함수/클래스를 매핑
             @GetMapping                        HTTP 요청 GET 함수 매핑
             @PostMapping                       HTTP 요청 Post 함수 매핑
             @PutMapping                        HTTP 요청 Put 함수 매핑
             @DeleteMapping                     HTTP 요청 Delete 함수 매핑
             @Service                           해당 클래스를 Service 사용 주입 [ 컨테이너에 빈 등록 ]
             @Component                         해당 클래스를 컨테이너에 빈 등록
                @RequestParam                   쿼리스트링 형식의 요청 매개변수 매핑                   URL?매개변수=값?매개변수=값
                @RequestBody                    HTTP body( Post/Put ) 형식의 요청 매개변수를 객체로 매핑
                - @ModelAttribute                 쿼리스트링 형식의 요청 매개변수를 객체로 매핑
                - @PathVariable                   경로상의 매개변수 형식의 요청 매개변수 매핑           URL/값/값
             @Repository                        Spring에서 리포지토리를 지정하기 위한 어노테이션 [ spring 컨테이너에 빈 등록]


    3. lombok
             @NoArgsConstructor                 빈 생성자 자동 생성
             @AllArgsConstructor                풀 생성자 자동 생성
             @Getter                            필드의 getter메소드 자동 생성
             @Setter                            필드의 setter메소드 자동 생성
             @ToString                          필드의 toString메소드 자동 생성
             @Builder                           빌더 패턴 [ 유연하게(생성자 단점 보완) 객체 생성 도와주는 함수 제공 ]

- HTML 반환
    Resource 클래스 사용
    경로 : return new ClassPathResource("/templates/todo.html");
    - 스프링은 기본적으로 resources 폴더내에서 정적파일 검색

- JPA
    1. entity
        @Entity                                               : 해당 클래스를 데이터베이스의 테이블과 매핑
        @Table(name="테이블명")                                 : 데이터 베이스의 테이블 이름 정의
        @ID                                                   : 해당 필드를 PK로 선정
        @GeneratedValue( strategy = GenerationType.IDENTITY ) : PK 정의할 방법 : auto_increment
        @Column(name="필드명" , length="최대문자수" , nullable=false , nullable = false , unique = true )
            name=" "            : 생략시 자바 필드명이 테이블 필드명을 자동 생성
            length="최대문자수"   : 필드내 데이터 최대 길이수 ( String 기본값 255 )
            nullable = false    : not null ( 기본값 true )
            unique = true       : nuique ( 기본값 false )

    2. Repository
        @Repository
        @Translation

    3. Jpa Auditing
        @EnableJpaAuditing
        @EntityListeners( AuditingEntityListeners.class )
        @MappedSuperclass
        @CreateDate
        @LastModifiedDate

    -----
        패러다임(=방식/체계/규정 틀)
        ORM( = Object Relational Mapping ) : 객체 관계 매핑
            - 객체 지향 프로그래밍   : 객체들간의 상호작용을 통한 프로그래밍
            - 관계형 데이터베이스    : 열/행의 테이블/관계로 데이터를 저장하는 방식
            + 관계형 데이터베이스를 객체지향으로 사용

        JPA : JAVA Persisten api : ORM 패러다임으로 만들어진 라이브러리

        엔티티클래스 = 테이블
        엔티티(객체) = 레코드
        -----
        MYSQL                 --------------------------> ORM 매핑 -------> JPA(ORM)
        테이블 TODO                                                       @Entity
            create table todo(                                           class todo (
                tno int auto_increment primary key ,                          private int tno;
                tcontent varchar(100) ,                                       private String tcontent;
                tstate boolean                                                private boolean tstate;
            );                                                           )
    -----
    1. 그레이들에 의존성 추가
     implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    - 스프링 실행시 DB연동
    - 경로 오류 [ 1. 경로 셋팅 안함 2. 경로에 오타 뜸 ]
        Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

    2. JPA 옵션 세팅
        - application.properties 에서 코드 작성
        ---- 연동에 필요한 필수 코드
        spring.datasource.driver.className = DBMS 드라이버 이름[ 각 회사마다 상이 ]
        spring.datasource.url= 연동할 데이터 베이스 경로
        spring.datasource.username=계정명
        spring.datasource.password=DB계정 패스워드
        ----
        spring.jpa.hibernate.ddl-auto = DDL자동실행.
            create : 만약에 매핑된 엔티티가 실제 DB에 없으면/있어도 (서버 실행할때마다)새로 테이블 생성
            update :
                만약에 매핑된 엔티티가 실제 DB에 없으면 새로운 테이블 생성
                만약에 매핑된 엔티티가 실제 DB에 있으면 테이블의 변경이 있으면 수정

    3. 엔티티(객체)
        1. 엔티티 생성시 필수
                1. @Entity (클래스 상단)
                2. @Id  (pk)
                    No identifier specified for entity: example.day06.NoteEntity
        2. 필드 선언 [ MYSQL과 JAVA 타입 변환 ]

    4. 엔티티 조작 [ 인터페이스 ]
        - JPARepository
            * 기본적인 CRUD 해당하는 SQL 지원
            * 선언 방법
                1. 인터페이스 생성
                2. @Repository
                3. public interface 인터페이스명 extends JpaRepository< 조작할엔티티클래스명 , 해당엔티티pk필드자료형 >
                    - 조작할때 PK필드가 식별 하므로 각 엔티티별 PK필드(@Id)는 필수

    5. 엔티티 인터페이스 사용처 [ 서비스에서만 사용(각 MVC별 역할 분담) ]
        1. CRUD
            1. insert
                인터페이스명.save( 저장할엔티티 )
                반환타입 :
            2. select
                인터페이스명.findAll()
                반환타입 : 검색된 엔티티 List<Entity>
                2.
                인터페이스명.findById( pk번호 )
                반환타입 : 검색된 엔티티 1개 Optional<TodoEntity>
                    Optional 클래스 : null 관련 메소드 제공 [ nullPointerExection 안전성 보장 ]
                    - nullPointerExection : 객체가 null 일때 발생하는 오류
                    1. .isPresent()
                        Optinal 객체를 사용하기전에 null 인지 아닌지 체크하고 사용
                    2. .get()
                        Optional 객체내 실제 객체(엔티티)를  꺼내기
            3.delete
                1.
                인터페이스명.delete( 삭제할 엔티티 객체 )
                반환타입: void
                2.
                인터페이스명.deleteById( 삭제할 pk번호 )
                반환타입 : void

            4.update
                엔티티객체명.set필드명( 새로운값 )
                @Transactional 필수
- 트랜잭션
    - 하나/여럿 작업[SQL]들을 묶어서 최소단위 업무처리
    - COMMIT : 최종완료 [ 마지막 commit 이후부터 현재 완료까지 ] -> SQL 결과 적용
    - Rollback : 뒤로가기/취소 [ 마지막 commit 으로 이동 ] -> SQL 결과 적용 불가능

                ----> 성공    ----> 부분완료 --COMMIT --> 완료
                                      |
    활용(실행 : SQL n개)                |
                                      |
                ----> 오류    ----> 실패   -- Rollback --> 철회

- HTTP

    HTTP : 문서 이동 규약
       보내고 받는 방법 = 편지봉투 [ contentType , method , 쿼리스트링 ]
         contentType
                   1. application/x-www-form-urlencoded ( AJAX 기본값 )
                        data : { }
                            [JAVA SPRING] Controller
                            1.
                                @PostMapping
                                NoteDto

                            2.
                                @PostMapping
                                @RequestBody NoteDto [ 자동 매핑 불가능 합니다. ] X


                   2. application/json                  ( AXIOS 기본값 )
                        data : json.stringify({ })
                            2.
                              @PostMapping
                              @RequestBody NoteDto [ 자동 매핑 불가능 합니다. ] X


                   3. text/html
                   4. multipart/form-data
                            @RequestBody NoteDto
                   5. dto

       내용물 = 편지지 [ Body : post , put ]

            data : { }

            1. JSON.Stringify() : json타입 --> 문자열타입
            2. JSON.parse()     : 문자열타입 --> json타입

           내용물 형식/생김새/양식
            "{ asaa:"ddd" }" json형식 문자열타입
            { asaa:"ddd" } json형식 json타입

            "1" 숫자형식 문자열타입
             1  숫자형식 정수형타입

    AJAX <----------------------HTTP------------------------> JAVA

    - AJAX [ HTTP 사용하는 함수 ]
    - WebSocket [ WS 사용하는 클래스 ]